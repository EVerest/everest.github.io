<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>4. EVerest Modules in Detail &#8212; EVerest  documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=649a27d8" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinxdoc.css?v=0a676766" />
    <link rel="stylesheet" type="text/css" href="../_static/contentui.css" />
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js?v=b3ba4146"></script>
    <script src="../_static/doctools.js?v=888ff710"></script>
    <script src="../_static/sphinx_highlight.js?v=4825356b"></script>
    <script src="../_static/contentui.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="5. EVerest Module Configurations" href="05_existing_modules.html" />
    <link rel="prev" title="3. A Kind Of Quick Guide To EVerest" href="03_quick_start_guide.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="05_existing_modules.html" title="5. EVerest Module Configurations"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="03_quick_start_guide.html" title="3. A Kind Of Quick Guide To EVerest"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">EVerest  documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><span class="section-number">4. </span>EVerest Modules in Detail</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="everest-modules-in-detail">
<span id="moduleconcept-main"></span><h1><span class="section-number">4. </span>EVerest Modules in Detail<a class="headerlink" href="#everest-modules-in-detail" title="Permalink to this heading">¶</a></h1>
<p>This section gives you a bunch of theoretical input about the EVerest module
concept.</p>
<p>Other ways to approach the concepts of EVerest module development are:</p>
<ol class="arabic simple">
<li><p>For a very first glance and understanding of EVerest modules, try to check
the <a class="reference internal" href="03_quick_start_guide.html#quickstartguide-modulesetup"><span class="std std-ref">Module Setup section</span></a> in the Quick
Start Guide.</p></li>
<li><p>A more hands-on intro to EVerest module development is the
<a class="reference internal" href="../tutorials/new_modules/index.html#tutorial-create-modules-main"><span class="std std-ref">Tutorial About Developing EVerest Modules</span></a>.</p></li>
</ol>
<section id="overview">
<h2><span class="section-number">4.1. </span>Overview<a class="headerlink" href="#overview" title="Permalink to this heading">¶</a></h2>
<p>EVerest follows a microservice-like architecture.
A typical EVerest deployment consists of the following components:</p>
<ul class="simple">
<li><p>Several <strong>module instances</strong>, which are separate processes offering some
type of functionality;</p></li>
<li><p>An <strong>MQTT broker</strong> (mosquitto), which provides the backbone of communication
between module instances;</p></li>
<li><p>A <strong>manager process</strong>, which orchestrates the execution of module instances.</p></li>
</ul>
<a class="reference internal image-reference" href="../_images/everest-manager-modules-mqtt.png"><img alt="../_images/everest-manager-modules-mqtt.png" class="align-center" src="../_images/everest-manager-modules-mqtt.png" style="width: 360px;" /></a>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>EVerest provides integration for modules written in C++, Javascript, Python
or Rust.
We will use notation for C++ below.</p>
</div>
</section>
<section id="concepts">
<h2><span class="section-number">4.2. </span>Concepts<a class="headerlink" href="#concepts" title="Permalink to this heading">¶</a></h2>
<section id="modules-and-module-instances">
<h3><span class="section-number">4.2.1. </span>Modules and module instances<a class="headerlink" href="#modules-and-module-instances" title="Permalink to this heading">¶</a></h3>
<p>A <strong>module</strong> is a program providing a specific functionality within EVerest,
e.g. driving a particular type of hardware.</p>
<p>Each module has a unique <strong>name</strong>, assigned at development time.
Modules can accept <strong>config</strong> values, which can be set when executing the
module.</p>
<p>In an EVerest deployment, you launch <strong>instances</strong> of these modules, each
instance is a separate process.</p>
<p>There can be multiple instances of the same module, e.g. for driving multiple
devices of the same type.</p>
<p>Each module instance has a unique <strong>instance ID</strong>, independent of the module
name, which is assigned when configuring the deployment.</p>
<p>Different instances of the same module can also have different config values
set when configuring the deployment.</p>
<a class="reference internal image-reference" href="../_images/everest-modules-and-instances.png"><img alt="../_images/everest-modules-and-instances.png" class="align-center" src="../_images/everest-modules-and-instances.png" style="width: 600px;" /></a>
</section>
<section id="interfaces-communication-between-modules">
<h3><span class="section-number">4.2.2. </span>Interfaces: Communication between modules<a class="headerlink" href="#interfaces-communication-between-modules" title="Permalink to this heading">¶</a></h3>
<p>Think of interfaces as specific protocols (or languages) that modules can use
to communicate with each other.</p>
<p>An interface is a set of:</p>
<ul class="simple">
<li><p><strong>Commands</strong>: Synchronous (remote) procedure calls with defined arguments
and return values - in short <strong>CMDs</strong>;</p></li>
<li><p><strong>Variables</strong>: Useful for asynchronous communication, a variable is a topic
(typically some particular value that changes over time) which users of the
interface can subscribe to, and which the module publishes updates on.
In short <strong>VARs</strong>.</p></li>
</ul>
<p>For example, imagine a simple interface offered by a power supply module.</p>
<p>Turning power on or off could be implemented as CMDs, callable by other
modules.</p>
<p>The voltage and current values at the power supply could be implemented as a VAR -
the power supply module publishes this VAR regularly,
and other modules could subscribe to the VAR and observe its value over time.</p>
</section>
<section id="providing-and-requiring-interfaces">
<h3><span class="section-number">4.2.3. </span>Providing and requiring interfaces<a class="headerlink" href="#providing-and-requiring-interfaces" title="Permalink to this heading">¶</a></h3>
<p>Each module defines a set of interface implementations it <strong>provides</strong> to
other modules, and a set of interface implementations it <strong>requires</strong> from
other modules.</p>
<section id="providing-interface-implementations">
<h4><span class="section-number">4.2.3.1. </span>Providing interface implementations<a class="headerlink" href="#providing-interface-implementations" title="Permalink to this heading">¶</a></h4>
<p>A module is not simply declared as an implementor of an interface.
Instead, modules have a set of <strong>interface implementations</strong>,
each implementing one interface and having a unique <strong>implementation ID</strong>.
This is done because a module can implement the same interface multiple times.
This is reflected by providing multiple implementations with different IDs for
the same interface.</p>
<p>As an analogy, think of an internet router.
It does not just implement the IP protocol, it has multiple implementations
of it (several Ethernet ports, WLAN antennas, etc.), which can be connected to
different devices, and may even have different purposes, e.g. LAN and WAN
ports.</p>
</section>
<section id="requiring-interface-implementations">
<h4><span class="section-number">4.2.3.2. </span>Requiring interface implementations<a class="headerlink" href="#requiring-interface-implementations" title="Permalink to this heading">¶</a></h4>
<p>Just like a module can provide the same interface multiple times, it can also
require multiple implementations of the same interface.
For example, there could be one energy manager component, which communicates
with multiple power supply or EVSE manager modules.</p>
<p>Therefore, modules have a set of <strong>interface requirements</strong> with unique
IDs, each of which is for a particular interface and must be satisfied by
an interface implementation of another module.</p>
<p>Continuing with the router analogy from before, a PC can have
multiple network interfaces - e.g. one WLAN and one Ethernet -
which could easily be connected to different ports on different routers.</p>
<p>The following diagram shows how providing and requiring interface
implementation create relations between modules:</p>
<a class="reference internal image-reference" href="../_images/everest-interfaces-provides-requires.png"><img alt="../_images/everest-interfaces-provides-requires.png" class="align-center" src="../_images/everest-interfaces-provides-requires.png" style="width: 420px;" /></a>
</section>
</section>
<section id="interface-communication-on-the-mqtt-layer">
<h3><span class="section-number">4.2.4. </span>Interface communication on the MQTT layer<a class="headerlink" href="#interface-communication-on-the-mqtt-layer" title="Permalink to this heading">¶</a></h3>
<p>On the MQTT level, interfaces are implemented as follows:</p>
<ul class="simple">
<li><p>To listen for incoming CMDs or subscribe to a VAR, a module
subscribes to the corresponding MQTT topic;</p></li>
<li><p>To send a CMD or update to a VAR, a module publishes a message on the
corresponding topic.</p></li>
</ul>
<p>The MQTT topic for commands is:
<code class="docutils literal notranslate"><span class="pre">everest/{module</span> <span class="pre">instance</span> <span class="pre">ID}/{interface</span> <span class="pre">implementation</span> <span class="pre">ID}/cmd</span></code>
Similarly, the MQTT topic for variables is:
<code class="docutils literal notranslate"><span class="pre">everest/{module</span> <span class="pre">instance</span> <span class="pre">ID}/{interface</span> <span class="pre">implementation</span> <span class="pre">ID}/var</span></code>
Note that the path prefix <code class="docutils literal notranslate"><span class="pre">everest</span></code> may differ in some end-to-end tests.</p>
</section>
<section id="wiring-it-all-together-the-run-configuration">
<h3><span class="section-number">4.2.5. </span>Wiring it all together: The run configuration<a class="headerlink" href="#wiring-it-all-together-the-run-configuration" title="Permalink to this heading">¶</a></h3>
<p>The <strong>run configuration</strong> is a YAML file which specifies the structure of your
deployment.
The run configuration defines the module instances to start:</p>
<ul class="simple">
<li><p>Their instance IDs;</p></li>
<li><p>Which modules they are an instance of;</p></li>
<li><p>What to set their configuration values to;</p></li>
<li><dl class="simple">
<dt>For each interface requirement of the module instance:</dt><dd><ul>
<li><p>The instance ID of the module instance which provides the interface;</p></li>
<li><p>The interface implementation ID within the providing module which will be used.</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</section>
</section>
<section id="explaining-the-yaml-files">
<h2><span class="section-number">4.3. </span>Explaining the YAML files<a class="headerlink" href="#explaining-the-yaml-files" title="Permalink to this heading">¶</a></h2>
<p>Now, we will show how the concepts above map to the YAML files
defining modules and interfaces.</p>
<p>Consider the following example: We want two modules, a “ping server” and a
“ping client”, to communicate over a “ping interface”.</p>
<p>Let us define the <code class="docutils literal notranslate"><span class="pre">interfaces/interface_ping.yaml</span></code> first:</p>
<div class="highlight-yaml notranslate"><div class="highlight"><pre><span></span><span class="nt">description</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">Interface for a ping-pong interaction</span>
<span class="nt">cmds</span><span class="p">:</span><span class="w"> </span><span class="c1"># list of commands in the interface</span>
<span class="w">  </span><span class="nt">command_ping</span><span class="p">:</span><span class="w"> </span><span class="c1"># name of the command</span>
<span class="w">    </span><span class="nt">description</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">Send a ping with a payload to the ping server.</span>
<span class="w">    </span><span class="nt">arguments</span><span class="p">:</span><span class="w"> </span><span class="c1"># list of arguments</span>
<span class="w">      </span><span class="nt">payload</span><span class="p">:</span>
<span class="w">        </span><span class="nt">description</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">An arbitrary string that the server will pong back.</span>
<span class="w">        </span><span class="nt">type</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">string</span>
<span class="w">    </span><span class="nt">result</span><span class="p">:</span><span class="w"> </span><span class="c1"># return value of the command</span>
<span class="w">      </span><span class="nt">description</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">The same payload as the ping</span>
<span class="w">      </span><span class="nt">type</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">string</span>
<span class="nt">vars</span><span class="p">:</span><span class="w"> </span><span class="c1"># list of variables in the interface</span>
<span class="w">  </span><span class="nt">var_nping</span><span class="p">:</span><span class="w"> </span><span class="c1"># name of the variable</span>
<span class="w">    </span><span class="nt">description</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">The number of pings the server has received so far</span>
<span class="w">    </span><span class="nt">type</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">integer</span>
</pre></div>
</div>
<p>Now, let us define a “ping server” module, which has an implementation of this
interface.</p>
<p>Here is the <code class="docutils literal notranslate"><span class="pre">modules/PingServerModule/manifest.yaml</span></code> file:</p>
<div class="highlight-yaml notranslate"><div class="highlight"><pre><span></span><span class="nt">description</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">Example ping-pong module</span>
<span class="nt">config</span><span class="p">:</span><span class="w"> </span><span class="c1"># list of config values</span>
<span class="w">  </span><span class="nt">cfg_publish_number_of_pings</span><span class="p">:</span><span class="w"> </span><span class="c1"># name of the config value</span>
<span class="w">    </span><span class="nt">description</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">Publish the number_of_pings variable every 5 seconds.</span>
<span class="w">    </span><span class="nt">type</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">boolean</span>
<span class="w">    </span><span class="nt">default</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">false</span>
<span class="nt">provides</span><span class="p">:</span><span class="w"> </span><span class="c1"># list of interface implementations</span>
<span class="w">  </span><span class="nt">if_impl_id_ping</span><span class="p">:</span><span class="w"> </span><span class="c1"># implementation ID</span>
<span class="w">    </span><span class="nt">interface</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">interface_ping</span><span class="w"> </span><span class="c1"># interface name</span>
<span class="w">    </span><span class="nt">description</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">Responds to a ping with a pong</span>
<span class="nt">enable_external_mqtt</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">true</span><span class="w"> </span><span class="c1"># enable this if you want to use the MQTT layer directly in your code</span>
<span class="nt">metadata</span><span class="p">:</span>
<span class="w">  </span><span class="nt">license</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">link-to-your-license.here</span>
<span class="w">  </span><span class="nt">authors</span><span class="p">:</span>
<span class="w">    </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">Max Mustermann, Company Name Here</span>
</pre></div>
</div>
<p>We can have a “ping client” module, which requires the <code class="docutils literal notranslate"><span class="pre">ping_interface</span></code>.</p>
<p>Here is the <code class="docutils literal notranslate"><span class="pre">modules/PingClientModule/manifest.yaml</span></code> file:</p>
<div class="highlight-yaml notranslate"><div class="highlight"><pre><span></span><span class="nt">description</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">Example ping-pong client module</span>
<span class="nt">provides</span><span class="p">:</span><span class="w"> </span><span class="c1"># list of interface implementations</span>
<span class="w">  </span><span class="nt">if_impl_id_empty</span><span class="p">:</span><span class="w"> </span><span class="c1"># there must be at least one, so we add a dummy interface</span>
<span class="w">    </span><span class="nt">interface</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">empty</span><span class="w"> </span><span class="c1"># the definition of this interface is in everest-core</span>
<span class="w">    </span><span class="nt">description</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">Dummy interface</span>
<span class="nt">requires</span><span class="p">:</span><span class="w"> </span><span class="c1"># list of interface requirements</span>
<span class="w">  </span><span class="nt">requirement_ping_server</span><span class="p">:</span><span class="w"> </span><span class="c1"># requirement ID</span>
<span class="w">    </span><span class="nt">interface</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">interface_ping</span><span class="w"> </span><span class="c1"># interface name</span>
<span class="nt">enable_external_mqtt</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">true</span><span class="w"> </span><span class="c1"># enable this if you want to use the MQTT layer directly in your code</span>
<span class="nt">metadata</span><span class="p">:</span>
<span class="w">  </span><span class="nt">license</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">link-to-your-license.here</span>
<span class="w">  </span><span class="nt">authors</span><span class="p">:</span>
<span class="w">    </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">Max Mustermann, Company Name Here</span>
</pre></div>
</div>
<p>And finally, we define a run configuration, where instances of the two modules
connect to each other:</p>
<div class="highlight-yaml notranslate"><div class="highlight"><pre><span></span><span class="nt">settings</span><span class="p">:</span>
<span class="w">  </span><span class="nt">telemetry_enabled</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">true</span>
<span class="nt">active_modules</span><span class="p">:</span><span class="w"> </span><span class="c1"># list of module instances</span>
<span class="w">  </span><span class="nt">instance_id_ping_server</span><span class="p">:</span><span class="w"> </span><span class="c1"># instance ID</span>
<span class="w">    </span><span class="nt">config_module</span><span class="p">:</span><span class="w"> </span><span class="c1"># list of config parameters</span>
<span class="w">      </span><span class="nt">cfg_publish_number_of_pings</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">true</span>
<span class="w">    </span><span class="nt">module</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">PingServerModule</span><span class="w"> </span><span class="c1"># module which this is an instance of</span>
<span class="w">  </span><span class="nt">instance_id_ping_client</span><span class="p">:</span><span class="w"> </span><span class="c1"># next instance ID</span>
<span class="w">    </span><span class="nt">connections</span><span class="p">:</span><span class="w"> </span><span class="c1"># list of providers for interface requirements</span>
<span class="w">      </span><span class="nt">requirement_ping_server</span><span class="p">:</span><span class="w"> </span><span class="c1"># requirement ID</span>
<span class="w">        </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="nt">implementation_id</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">if_impl_id_ping</span><span class="w"> </span><span class="c1"># implementation ID</span>
<span class="w">          </span><span class="nt">module_id</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">instance_id_ping_server</span><span class="w"> </span><span class="c1"># module instance ID of the provider</span>
<span class="w">    </span><span class="nt">module</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">PingClientModule</span><span class="w"> </span><span class="c1"># module which this is an instance of</span>
</pre></div>
</div>
<p>Graphically, this would look as follows:</p>
<a class="reference internal image-reference" href="../_images/everest-runtime-config.png"><img alt="../_images/everest-runtime-config.png" class="align-center" src="../_images/everest-runtime-config.png" style="width: 480px;" /></a>
<p>For a tutorial where you implement and experiment a similar example,
refer to
<a class="reference internal" href="../tutorials/new_modules/index.html#tutorial-create-modules-main"><span class="std std-ref">this EVerest module development tutorial</span></a>.</p>
</section>
<section id="explaining-the-generated-sources">
<h2><span class="section-number">4.4. </span>Explaining the generated sources<a class="headerlink" href="#explaining-the-generated-sources" title="Permalink to this heading">¶</a></h2>
<p>When starting a project, you will typically use <code class="docutils literal notranslate"><span class="pre">ev-cli</span></code> to generate a
source code skeleton.</p>
<p>Here, we will explain the purpose and structure of the files
created by this code generation step.</p>
<section id="interface-headers">
<h3><span class="section-number">4.4.1. </span>Interface headers<a class="headerlink" href="#interface-headers" title="Permalink to this heading">¶</a></h3>
<p>Using <code class="docutils literal notranslate"><span class="pre">ev-cli</span> <span class="pre">generate-headers</span></code> for the <code class="docutils literal notranslate"><span class="pre">interface_ping</span></code> from above,
three header files are generated:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>.
└── build
    └── generated
        └── include
            └── generated
                └── interfaces
                    └── interface_ping
                        ├── Implementation.hpp
                        ├── Interface.hpp
                        └── Types.hpp
</pre></div>
</div>
<p>We will not list the contents of these files completely,
but we will explain the contents of the files generally.</p>
<p><code class="docutils literal notranslate"><span class="pre">Interface.hpp</span></code> contains a class called <code class="docutils literal notranslate"><span class="pre">interface_pingIntf</span></code>
(in general, <code class="docutils literal notranslate"><span class="pre">${INTERFACE_NAME}Intf</span></code>),
which is used when <em>requiring</em> the interface.
It contains the following functions:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">call_command_ping</span></code> (in general <code class="docutils literal notranslate"><span class="pre">call_${COMMAND_NAME}</span></code>), to call the
respective command;</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">subscribe_var_nping</span></code> (in general <code class="docutils literal notranslate"><span class="pre">subscribe_${VAR_NAME}</span></code>) to register a
callback each time an update to the variable is published.</p></li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">${INTERFACE_NAME}Intf</span></code> is essentially a proxy which routes command calls
and variable subscriptions to the EVerest framework.</p>
<p><code class="docutils literal notranslate"><span class="pre">Implementation.hpp</span></code> contains an abstract class called
<code class="docutils literal notranslate"><span class="pre">interface_pingImplBase</span></code>
(in general, <code class="docutils literal notranslate"><span class="pre">${INTERFACE_NAME}ImplBase</span></code>), which is used
when <em>providing</em> the interface.</p>
<p>It contains the following functions:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">publish_var_nping</span></code> (in general <code class="docutils literal notranslate"><span class="pre">publish_${VAR_NAME}</span></code>), to publish an
update to the variable;</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">handle_command_ping</span></code> (in general <code class="docutils literal notranslate"><span class="pre">handle_${COMMAND_NAME}</span></code>), which is
virtual - this function is called to handle the respective command.</p></li>
</ul>
<p>Interface implementations extend <code class="docutils literal notranslate"><span class="pre">${INTERFACE_NAME}ImplBase</span></code>, and must
implement all command handlers (<code class="docutils literal notranslate"><span class="pre">handle_${COMMAND_NAME}</span></code>).</p>
<p>The EVerest framework takes care of publishing variable updates,
listening for commands, calling the appropriate handler, and sending back its
return value to the caller.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">Types.hpp</span></code> file contains custom type definitions.</p>
</section>
<section id="module-files">
<h3><span class="section-number">4.4.2. </span>Module files<a class="headerlink" href="#module-files" title="Permalink to this heading">¶</a></h3>
<p>Using <code class="docutils literal notranslate"><span class="pre">ev-cli</span> <span class="pre">module</span> <span class="pre">create</span></code> for the two modules from above generates
the following new files (we omit the <code class="docutils literal notranslate"><span class="pre">manifest.yaml</span> <span class="pre">here</span></code>):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>.
└── modules
    ├── PingServerModule
    │   ├── CMakeLists.txt
    │   ├── PingServerModule.cpp
    │   ├── PingServerModule.hpp
    │   ├── doc.rst
    │   ├── docs
    │   │   └── index.rst
    │   └── if_impl_id_ping
    │       ├── interface_pingImpl.cpp
    │       └── interface_pingImpl.hpp
    │
    └── PingClientModule
        ├── CMakeLists.txt
        ├── PingClientModule.cpp
        ├── PingClientModule.hpp
        ├── doc.rst
        ├── docs
        │   └── index.rst
        └── if_impl_id_empty
            ├── emptyImpl.cpp
            └── emptyImpl.hpp
</pre></div>
</div>
<p>Focusing on the source and header files, generally, the tool generates:</p>
<ul class="simple">
<li><p>One source-header pair describing a class for the whole module:
<code class="docutils literal notranslate"><span class="pre">${MODULE_NAME}.{cpp,</span> <span class="pre">hpp}</span></code>;</p></li>
<li><p>One source-header pair describing a class for each interface implementation
in the module: <code class="docutils literal notranslate"><span class="pre">${IMPLEMENTATION_ID}/${INTERFACE_NAME}Impl.{cpp,</span> <span class="pre">hpp}</span></code></p></li>
</ul>
<section id="the-module-class">
<h4><span class="section-number">4.4.2.1. </span>The module class<a class="headerlink" href="#the-module-class" title="Permalink to this heading">¶</a></h4>
<p>The module class, which carries the same name as the module itself, is defined
in <code class="docutils literal notranslate"><span class="pre">${MODULE_NAME}.hpp</span></code>.</p>
<p>Apart from a constructor (called by the EVerest framework on startup), it has
a few notable members:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">config</span></code> of type <code class="docutils literal notranslate"><span class="pre">Conf</span></code> (defined in the same file): Config values for
the module;</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">mqtt</span></code>: handle for MQTT communication, if <code class="docutils literal notranslate"><span class="pre">enable_external_mqtt</span></code> was
enabled in the manifest;</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">init()</span></code>: Function called by the framework after initializing this module
- you may add code to it to add more initialization steps;</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ready()</span></code>: Function called by the framework when the deployment is ready
- you may initiate application logic in it;</p></li>
<li><p>For each interface implementation:
<code class="docutils literal notranslate"><span class="pre">std::unique_ptr&lt;${INTERFACE_ID}ImplBase&gt;</span> <span class="pre">p_${IMPLEMENTATION_ID}</span></code>
- reference to the interface implementation;</p></li>
<li><p>For each interface requirement:
<code class="docutils literal notranslate"><span class="pre">std::unique_ptr&lt;${INTERFACE_ID}Intf&gt;</span> <span class="pre">r_${REQUIREMENT_ID}</span></code> - use this to
trigger commands or subscribe to variables on the provider.</p></li>
</ul>
<p>The header file contains designated areas where further members or other
definitions can be added.</p>
<p>Code added to these areas will be preserved if the headers are
overwritten by the <code class="docutils literal notranslate"><span class="pre">ev-cli</span> <span class="pre">module</span> <span class="pre">update</span></code> command (e.g. if you updated
the module manifest).</p>
<p><code class="docutils literal notranslate"><span class="pre">${MODULE_NAME}.cpp</span></code> initially only contains stub implementations of the
<code class="docutils literal notranslate"><span class="pre">init()</span></code> and <code class="docutils literal notranslate"><span class="pre">ready()</span></code> functions, which just call the <code class="docutils literal notranslate"><span class="pre">init()</span></code> and
<code class="docutils literal notranslate"><span class="pre">ready()</span></code> functions in each interface implementation:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">PingServerModule::init</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">invoke_init</span><span class="p">(</span><span class="o">*</span><span class="n">p_if_impl_id_ping</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">PingServerModule::ready</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">invoke_ready</span><span class="p">(</span><span class="o">*</span><span class="n">p_if_impl_id_ping</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Further logic can be freely added to this file - <code class="docutils literal notranslate"><span class="pre">${MODULE_NAME}.cpp</span></code> is
not overwritten by <code class="docutils literal notranslate"><span class="pre">ev-cli</span> <span class="pre">module</span> <span class="pre">update</span></code>, unless the <code class="docutils literal notranslate"><span class="pre">--force</span></code> option
is specified.</p>
<p>Definitions related to the module class are placed in the <code class="docutils literal notranslate"><span class="pre">module</span></code> namespace.</p>
</section>
<section id="interface-implementations">
<h4><span class="section-number">4.4.2.2. </span>Interface implementations<a class="headerlink" href="#interface-implementations" title="Permalink to this heading">¶</a></h4>
<p>For each interface implementation, a class is defined in
<code class="docutils literal notranslate"><span class="pre">${IMPLEMENTATION_ID}/${INTERFACE_NAME}Impl.hpp</span></code>.</p>
<p>This class extends <code class="docutils literal notranslate"><span class="pre">${INTERFACE_NAME}ImplBase</span></code>, declaring overriding methods
for all command handlers, as well as a few additional notable members:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">config</span></code> of type <code class="docutils literal notranslate"><span class="pre">Conf</span></code> (defined in the same file): Config values
(TODO: Is this unused?);</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">mod</span></code>: reference to the module instance (e.g. to call methods of the
module class);</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">init()</span></code> and <code class="docutils literal notranslate"><span class="pre">ready()</span></code>, which have the same semantics as the module
class’s <code class="docutils literal notranslate"><span class="pre">init()</span></code> and <code class="docutils literal notranslate"><span class="pre">ready()</span></code>.</p></li>
</ul>
<p>Like the module class, interface implementation classes are also
constructed by the framework at startup.</p>
<p><code class="docutils literal notranslate"><span class="pre">${IMPLEMENTATION_ID}/${INTERFACE_NAME}Impl.cpp</span></code> initially contains stub
implementations of the
<code class="docutils literal notranslate"><span class="pre">init()</span></code> and <code class="docutils literal notranslate"><span class="pre">ready()</span></code> functions - recall from the previous subsection
that these are called by the module class’s <code class="docutils literal notranslate"><span class="pre">init()</span></code> and <code class="docutils literal notranslate"><span class="pre">ready()</span></code>
functions, therefore they are called at (roughly) the same point.
It also contains stubs for the command handlers, which return dummy values -
this way, the code generated by <code class="docutils literal notranslate"><span class="pre">ev-cli</span></code> can be built and ran
even if you have not yet written any code.</p>
<p>As was the case for the module class’s files, you may freely extend the
<code class="docutils literal notranslate"><span class="pre">${IMPLEMENTATION_ID}/${INTERFACE_NAME}Impl.cpp</span></code> file as it will not be
overwritten by subsequent <code class="docutils literal notranslate"><span class="pre">ev-cli</span> <span class="pre">module</span> <span class="pre">update</span></code> commands - however,
<code class="docutils literal notranslate"><span class="pre">${IMPLEMENTATION_ID}/${INTERFACE_NAME}Impl.hpp</span></code> does get overwritten, so
you should only add your changes to the designated areas in that file.</p>
<p>Definitions related to the interface implementation are in the
<code class="docutils literal notranslate"><span class="pre">module.${IMPLEMENTATION_ID}</span></code> namespace.</p>
</section>
<section id="note-on-concurrency">
<h4><span class="section-number">4.4.2.3. </span>Note on concurrency<a class="headerlink" href="#note-on-concurrency" title="Permalink to this heading">¶</a></h4>
<p>Parts of the module logic may run in parallel. By itself, the EVerest
framework starts:</p>
<ul class="simple">
<li><p>One thread to execute the <code class="docutils literal notranslate"><span class="pre">ready()</span></code> function of the module class, which
you can freely use to start logic of your own (e.g. an endless loop, or
spawning worker threads);</p></li>
<li><p>A thread pool to handle commands (these will call the command handlers in
interface implementations);</p></li>
<li><p>A thread pool to watch for variable updates the module has subscribed to
(these will call the callbacks you provide to <code class="docutils literal notranslate"><span class="pre">subscribe_${VAR_NAME}</span></code>)</p></li>
</ul>
<p>In general, assume functions called by the framework may be running in
parallel. If data structures need to be shared between such functions
(especially for writing), you should probably use some form of locking.</p>
</section>
</section>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h3><a href="../index.html">Table of Contents</a></h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="01_framework.html">1. EVerest framework</a></li>
<li class="toctree-l1"><a class="reference internal" href="02_detail_pre_setup.html">2. Prepare Your Development Environment</a></li>
<li class="toctree-l1"><a class="reference internal" href="03_quick_start_guide.html">3. A Kind Of Quick Guide To EVerest</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">4. EVerest Modules in Detail</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#overview">4.1. Overview</a></li>
<li class="toctree-l2"><a class="reference internal" href="#concepts">4.2. Concepts</a></li>
<li class="toctree-l2"><a class="reference internal" href="#explaining-the-yaml-files">4.3. Explaining the YAML files</a></li>
<li class="toctree-l2"><a class="reference internal" href="#explaining-the-generated-sources">4.4. Explaining the generated sources</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="05_existing_modules.html">5. EVerest Module Configurations</a></li>
<li class="toctree-l1"><a class="reference internal" href="06_handling_bank_cards.html">6. Bank Card Payment</a></li>
<li class="toctree-l1"><a class="reference internal" href="07_configure_plug_and_charge.html">7. Configure Plug&amp;Charge</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev_tools/index.html">8. EVerest development tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tutorials/index.html">9. Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="faq.html">10. Frequently Asked Questions And Best Practices</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hardware/pionix_belay_box.html">11. Pionix BelayBox</a></li>
<li class="toctree-l1"><a class="reference internal" href="../appendix/02_snapshot.html">12. Snapshot</a></li>
<li class="toctree-l1"><a class="reference internal" href="../appendix/01_everest_reference/index.html">13. EVerest Reference</a></li>
</ul>

  <div>
    <h4>Previous topic</h4>
    <p class="topless"><a href="03_quick_start_guide.html"
                          title="previous chapter"><span class="section-number">3. </span>A Kind Of Quick Guide To EVerest</a></p>
  </div>
  <div>
    <h4>Next topic</h4>
    <p class="topless"><a href="05_existing_modules.html"
                          title="next chapter"><span class="section-number">5. </span>EVerest Module Configurations</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/general/04_detail_module_concept.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div><h3>Community</h3>
<ul class="nav nav-sidebar">
<li><a href="https://lists.lfenergy.org/g/everest" target="_blank"><img src="../_static/icons/mail.svg" style="height: 0.8em" /> Get Support</a></li>
<li><a href="https://www.youtube.com/@lfe_everest" target="_blank"><img src="../_static/icons/youtube.svg" style="height: 0.8em" /> YouTube Channel</a></li>
<li><a href="https://twitter.com/everestincharge" target="_blank"><img src="../_static/icons/twitter.svg" style="height: 0.8em" /> Twitter</a></li>
<li><a href="https://fosstodon.org/@EVerest" target="_blank">Mastodon</a></li>
</ul>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="05_existing_modules.html" title="5. EVerest Module Configurations"
             >next</a> |</li>
        <li class="right" >
          <a href="03_quick_start_guide.html" title="3. A Kind Of Quick Guide To EVerest"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">EVerest  documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><span class="section-number">4. </span>EVerest Modules in Detail</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
    &#169; Copyright 2021, Pionix GmbH.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 7.1.2.
    </div>
  </body>
</html>